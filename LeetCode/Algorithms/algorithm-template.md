# Monotonic Stack — 深度算法模板（完整理解版）

# 单调栈算法深度讲解模板（零基础可读）

---

# 1️⃣ 什么是单调栈？

单调栈（Monotonic Stack）是一种特殊的栈结构：

👉 栈内元素按某种单调顺序排列（递增或递减）

它的核心作用是：

> 在 O(n) 时间内解决 “下一个更大/更小元素” 类型问题

---

# 2️⃣ 单调栈解决什么问题？

典型题型：

- Next Greater Element（下一个更大元素）
- Next Smaller Element（下一个更小元素）
- Daily Temperatures
- Largest Rectangle in Histogram
- Trapping Rain Water
- Sum of Subarray Minimums

核心共同点：

👉 每个元素都要找 “左/右边第一个更大或更小的元素”

---

# 3️⃣ 为什么单调栈是 O(n)？

虽然代码看起来像：

```python
for i in range(n):
    while stack and condition:
        stack.pop()
```

但每个元素：

- 最多入栈一次
- 最多出栈一次

总操作次数 ≤ 2n

因此时间复杂度 = O(n)

---

# 4️⃣ 单调栈核心思维模型

🧠 栈里存的是什么？

> 尚未找到答案的索引

🧠 栈保持什么？

- 找更大元素 → 单调递减栈
- 找更小元素 → 单调递增栈

🧠 当前元素做什么？

- 如果当前元素更大/更小
- 它可以“解决”栈顶元素

---

# 5️⃣ 单调递减栈模板（找下一个更大元素）

```python
stack = []
for i in range(len(nums)):
    while stack and nums[i] > nums[stack[-1]]:
        idx = stack.pop()
        # 在这里处理 idx
    stack.append(i)
```

逻辑解释：

- 栈中保持递减顺序
- 当前元素大于栈顶 → 栈顶找到更大元素

---

# 6️⃣ 单调递增栈模板（找下一个更小元素）

```python
stack = []
for i in range(len(nums)):
    while stack and nums[i] < nums[stack[-1]]:
        idx = stack.pop()
        # 在这里处理 idx
    stack.append(i)
```

逻辑解释：

- 栈中保持递增顺序
- 当前元素更小 → 栈顶找到更小元素

---

# 7️⃣ 详细例子演示（Daily Temperatures）

输入：

```
[73,74,75,71,69,72,76,73]
```

初始：

```
stack = []
ans = [0,0,0,0,0,0,0,0]
```

逐步过程：

| i | temp | stack (索引) | 操作 |
|---|------|--------------|------|
|0|73|[]|push 0|
|1|74|[0]|74>73 → pop 0, ans[0]=1; push 1|
|2|75|[1]|75>74 → pop 1, ans[1]=1; push 2|
|3|71|[2]|push 3|
|4|69|[2,3]|push 4|
|5|72|[2,3,4]|72>69 pop4; 72>71 pop3; push5|
|6|76|[2,5]|76>72 pop5; 76>75 pop2; push6|
|7|73|[6]|push7|

最终：

```
[1,1,4,2,1,1,0,0]
```

---

# 8️⃣ 详细例子演示（Largest Rectangle）

输入：

```
[2,1,5,6,2,3]
```

目标：

找每个柱子的左右边界。

最终：

```
left  = [-1,-1,1,2,1,4]
right = [1,6,4,4,6,6]
```

面积计算：

```
width = right[i] - left[i] - 1
area = height * width
```

最大面积 = 10

---

# 9️⃣ 为什么要用 >= 而不是 > ？

如果使用 >：

```
[2,2,2]
```

相等高度不会弹出，会导致边界错误。

使用 >=：

相等高度会被合并，宽度计算正确。

---

# 🔟 单调栈的本质

单调栈不是“为了排序”。

它的本质是：

> 延迟计算 + 批量结算

当前元素到来时：

- 解决一批之前未解决的元素
- 并保证栈始终保持单调

---

# 1️⃣1️⃣ 常见错误

- 栈存值而不是索引
- 忘记处理相等情况
- 宽度公式写错
- 忘记清空栈进行第二次扫描

---

# 1️⃣2️⃣ 心智模型总结

单调栈 = 一种“延迟决策结构”

它的作用是：

- 保存未解决问题
- 当条件满足时批量处理

---

# 结论

单调栈适用于：

- 需要找“最近的更大/更小元素”
- 希望从 O(n²) 优化到 O(n)

---

# END
